<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Peter's Blog]]></title>
  <link href="http://codefunny.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://codefunny.github.io/"/>
  <updated>2015-08-10T11:49:41+08:00</updated>
  <id>http://codefunny.github.io/</id>
  <author>
    <name><![CDATA[Peter]]></name>
    <email><![CDATA[winchaozheng@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【iOS】HTTPS的使用学习]]></title>
    <link href="http://codefunny.github.io/blog/2015/08/10/ios-https/"/>
    <updated>2015-08-10T11:46:31+08:00</updated>
    <id>http://codefunny.github.io/blog/2015/08/10/ios-https</id>
    <content type="html"><![CDATA[<p>使用HTTPS最主要的考虑就是数据的安全性。对于HTTPS如何确保数据安全，依靠的就是SSL/TSL层的加密机制。HTTPS也就是在原来的HTTP层的基础上增加了一个安全层。</p>

<p>我们需要了解的是HTTPS在建立安全连接时采取四次握手机制,会话密钥的产生。使用会话密钥主要是因为建立安全机制的密钥算法是非对称算法(一般是RSA)，计算比较耗时，而会话密钥使用的是对称密钥，可以提高会话的效率。</p>

<!-- more -->


<ol>
<li>客户端向服务器端发起连接请求，上送信息有：支持协议版本、随机数1、加密方法、支持压缩算法；</li>
<li>服务器回应，下发信息有：确认协议版本、随机数2、确认加密方法、服务器公钥证书；</li>
<li>客户端再次上送信息：随机数3(采用公钥加密)、编码改变通知、客户端握手结束通知；</li>
<li>服务器采用随机数1、随机数2和随机数3组成会话密钥，并回应：编码改变通知、服务器握手结束通知。</li>
</ol>


<p>以上四次握手中，完成了几件事情，第一，证书下发；第二，会话密钥；第三，确认双方参数(双方协议版本、加密方法等)。其中随机数1和随机数2是明文，随机数3是密文，之所以采用三个随机数来确定会话密钥，主要是三组随机数组成的随机数，确保了随机数的随机性，从而保证每次生成的会话密钥的安全性。</p>

<p>在默认情况下，iOS要求连接的HTTPS站点必须为CA签名过得合法证书。AFNetworking基于iOS的HTTP网络通讯库，自然在证书方面要求和系统是一致，也需要合法的站点证书。所以探讨HTTPS在iOS开发中的使用，我们主要考虑两个问题，一个是合法证书，一个是自建证书。</p>

<p>先来了解一下系统API的验证流程，HTTPS的相关API在Security.Framework中，如下：</p>

<ol>
<li>获取需要验证的信任对象(Trust Object)，在NSURLConnection来说，是从delegate方法<strong>-connection:willSendRequestForAuthenticationChallenge:</strong>回调回来的参数challenge中获取(<strong>[challenge.protectionSpace serverTrust]</strong>);</li>
<li>采用系统默认方式验证Trust Object,SecTrustEvaluate会根据Trust Object的验证策略，一级一级往上，验证证书上每一级数字签名的有效性，从而评估证书的有效性；</li>
<li>通过上一步，一般安全要求下，直接验证通过，下一步使用Trust Object生成一份凭证(<strong>[NSURLCredential credentialForTrust:serverTrust]</strong>)，传入challenge的sender中(<strong>[challenge.sender useCredential:cred forAuthenticationChallenge:challenge]</strong>)处理，建立连接；</li>
<li>如果有更强的安全要求，还可以继续对Trust Object进行更严格验证，常用方式为在本地导入证书，验证Trust Object与导入证书是否匹配；</li>
<li>如果验证失败，取消此次Challenge-Response Authentication验证流程，拒绝连接请求。</li>
</ol>


<p>如果是自建证书，那么会跳过第二步，因为自建证书的根CA数字签名不在系统的信任列表中。</p>

<p>上代码</p>

<pre><code class="objc ">// Now start the connection
NSURL * httpsURL = [NSURL URLWithString:@"https://www.google.com"];
self.connection = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:httpsURL] delegate:self];

//回调
- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge {
    //1)获取trust object
    SecTrustRef trust = challenge.protectionSpace.serverTrust;
    SecTrustResultType result;

   //2)SecTrustEvaluate对trust进行验证
    OSStatus status = SecTrustEvaluate(trust, &amp;result);
    if (status == errSecSuccess &amp;&amp;
        (result == kSecTrustResultProceed ||
        result == kSecTrustResultUnspecified)) {

   //3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
        [challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
    } else {
        //5)验证失败，取消这次验证流程
        [challenge.sender cancelAuthenticationChallenge:challenge];

  }
}
</code></pre>

<p>对于自建证书我们需要先在本地导入证书，设置成需要验证的Anchor Certificate，再来验证。如下：</p>

<pre><code class="objc">//先导入证书
NSString * cerPath = ...; //证书的路径
NSData * cerData = [NSData dataWithContentsOfFile:cerPath];
SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)(cerData));
self.trustedCertificates = @[CFBridgingRelease(certificate)];

//回调
- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge {
    //1)获取trust object
    SecTrustRef trust = challenge.protectionSpace.serverTrust;
    SecTrustResultType result;

    //注意：这里将之前导入的证书设置成下面验证的Trust Object的anchor certificate
    SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);

    //2)SecTrustEvaluate会查找前面SecTrustSetAnchorCertificates设置的证书或者系统默认提供的证书，对trust进行验证
    OSStatus status = SecTrustEvaluate(trust, &amp;result);
    if (status == errSecSuccess &amp;&amp;
        (result == kSecTrustResultProceed ||
        result == kSecTrustResultUnspecified)) {

        //3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
        [challenge.sender useCredential:cred forAuthenticationChallenge:challenge];

    } else {

        //5)验证失败，取消这次验证流程
        [challenge.sender cancelAuthenticationChallenge:challenge];

  }
}
</code></pre>

<p>一般我们很少直接使用原生API，而是使用AFNetworking封装好的接口来完成以上繁琐的过程，目前AFNetworking也已经更新到2.x版本了。</p>

<p>一般我们只需要如下代码就可使接口支持HTTPS：</p>

<pre><code class="objc">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];
    securityPolicy.allowInvalidCertificates = YES;
</code></pre>

<p>对于自建证书，AFNetworking2也是支持的，需要将pem格式的证书转成cer格式的，可以在mac下使用如下命令行：<strong>openssl x509 -in &lt;你的服务器证书>.pem -outform der -out server.cer</strong>将该证书引入到ap的bundle目录里，AFNetworking会自动扫描boundle中的.cer文件。</p>

<pre><code class="objc">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];
或者
AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];
securityPolicy.allowInvalidCertificates = YES; //还是必须设成YES
</code></pre>

<p>上面只列了一个参数，我想下面技术最好都要知道：</p>

<pre><code class="objc">//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO
//主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
securityPolicy.validatesDomainName = NO;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证；
securityPolicy.validatesCertificateChain = NO;
</code></pre>

<p>另外需要知道的是，验证站点证书时通过域名的，如果服务器站点没有绑定域名，仅靠IP地址，上面的方法是不行的，解决的办法就是修改AFNetworking2的代码，在AFSecurityPolicy.m文件中，修改：<strong>- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                  forDomain:(NSString *)domain</strong>方法，将里面的部分校验代码注释掉：</p>

<pre><code class="objc">//            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);
//
//            if (!AFServerTrustIsValid(serverTrust)) {
//                return NO;
//            }
//
//            if (!self.validatesCertificateChain) {
//                return YES;
//            }
</code></pre>

<p>有了上面的了解，我们就可以去实践一下HTTPS的开发了。Enjoy it！</p>

<p>学习来源：</p>

<ol>
<li><a href="http://my.oschina.net/non6/blog/290175">iOS实用技巧 - AFNetworking2安全的使用自签证书访问HTTPS</a></li>
<li><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/">iOS安全系列之一：HTTPS</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL/TLS协议</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【IOS】Reveal利器之使用]]></title>
    <link href="http://codefunny.github.io/blog/2015/07/23/ios-reveal-apply/"/>
    <updated>2015-07-23T12:00:01+08:00</updated>
    <id>http://codefunny.github.io/blog/2015/07/23/ios-reveal-apply</id>
    <content type="html"><![CDATA[<p>网上有很多教程，我结合自己的经验，总结了一个方便地使用方法，在下面描述我的使用流程。</p>

<!-- more -->


<p>1.获得Reveal的framework，在Reveal中拿到Reveal.framework拷贝到一个目录，本地调试UI都引用这个目录的framework，不用copy到具体的工程中；</p>

<p>2.在工程中新建一个Tagets，命名位RevealTest区分一下，然后在Build Setting中的Other Linker Flags项添加-ObjC -framework Reveal两项；</p>

<p>3.别忘了在Linked Frameworks and Libraries中添加Reveal.framework进来。</p>

<p>4.接下来就是启动Reveal和工程了，注意要编译的是RevealTest目标，这样就不用担心对生产版本造成影响了。</p>

<p>附：比较方便的办法是copy一下TARGETS，然后添加上面的设置，不过copy一份targets发现identifier后面加了一个copy字样，可能会有一些警告之类的信息，可以到Build Setting中修改Product Name，去掉后面的copy字符即可。</p>

<p>展示一个我的项目的UI截图，</p>

<p><img src="http://codefunny.github.io/images/custom_images/zhiyue-reveal.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【IOS】只有RSA模和指数，如何完成加密]]></title>
    <link href="http://codefunny.github.io/blog/2015/07/04/ios-rsa/"/>
    <updated>2015-07-04T17:02:23+08:00</updated>
    <id>http://codefunny.github.io/blog/2015/07/04/ios-rsa</id>
    <content type="html"><![CDATA[<blockquote><p>最近在项目中遇到RSA的加密解密问题，如果采用一般证书的方式也就没有这篇文章了，情况是这样的，RSA公钥存在服务器，需要联机获取，可以获取到RSA密钥的模值、有效期、指数、算法标识、索引等信息，这些信息是ASCII码格式，这些信息如何利用IOS的加密API进行RSA运算就成了一个问题。这篇文章就是记述探索问题答案的过程，希望对遇到同样问题的同行有所帮助。</p></blockquote>

<!-- more -->


<h4>获取的RSA模和指数</h4>

<pre><code>modulus: ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1
exponent:
010001
</code></pre>

<p>这是ASCII格式的公钥，在网上查询了一下RSA公钥的格式，发现X.509 DER编码和X.509 PAM编码，其中DER编码是ASCII格式，PAM编码是Base64格式，且他们只放证书，不含私钥。根据模值，可以判断，我们采用的应该是DER编码。那么DER编码的格式，就要弄清楚一下了。</p>

<h4>X.509 DER编码格式</h4>

<p>网上有一篇文章<a href="http://m.blog.csdn.net/blog/lingruoshui/11473755">RSA公钥DER编码</a>根据这篇文章可以推断出我们的DER编码格式应该是这样的，</p>

<pre><code>30818902818100ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C10203010001
解析一下可以分成以下几个部分（大家可以了解以下TLV结构）：
308189：30开始，81代表后面一个字节表示长度，89表示后面有137字节；
028181：02开始，81同上，81表示modulus长度129，前面补了00；
00ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1：modulus
0203010001：02开始，03表示后面三个字节，exponent值（010001）。
</code></pre>

<h4>RSA在IOS中的常见用法</h4>

<p><a href="http://blog.iamzsx.me/show.html?id=155002">iOS下的RSA加密方法</a>这篇文章常见用法之一，使用公钥证书，利用系统方法最终获得<strong>SecKeyRef publicKey</strong>，但是我们现在遇到的问题就是没有证书，我尝试过利用上面组装的DER送给<strong>SecCertificateCreateWithData</strong>，但是结果是返回nil值，这说明，我们的格式还不是该方法的参数，那么该方法的参数是神马呢，我跟踪了一个公钥证书，打印NSData值，发现其编码格式如下（中间部分经过我的处理，方便大家观察）：</p>

<pre><code>308202e4 3082024d a0030201 02020900 b524e21a d8b61f68 300d0609 2a864886 f70d0101 05050030 818a310b 30090603 55040613 02434e31 11300f06 03550408 0c085368 616e6768 61693111 300f0603 5504070c 08536861 6e676861 69310e30 0c060355 040a0c05 42616979 69310e30 0c060355 040b0c05 42616979 69311030 0e060355 04030c07 596f726b 2e477531 23302106 092a8648 86f70d01 09011614 67797135 33313939 32304067 6d61696c 2e636f6d 301e170d 31313130 32363032 34353332 5a170d31 31313132 35303234 3533335a 30818a31 0b300906 03550406 1302434e 3111300f 06035504 080c0853 68616e67 68616931 11300f06 03550407 0c085368 616e6768 6169310e 300c0603 55040a0c 05426169 7969310e 300c0603 55040b0c 05426169 79693110 300e0603 5504030c 07596f72 6b2e4775 31233021 06092a86 4886f70d 01090116 14677971 35333139 39323040 676d6169 6c2e636f 6d30819f
    300d0609 2a864886 f70d0101 010500
    03 818d
    0030 81890281 81
    00addc 2b26bba0 e8bc8d53 2444656e 367fd289 24b5cb99 2728b87a b7df09ba 4043259a a8df42d5 3d75cbf6 71dc6170 53ba5260 ceeb4238 6431c3c3 837c02af 5d8c665f b42f2f09 49445133 aeace2dd e00cd856 2d65978a 6e057a3f 18a63b00 86e83a9a 16a77c5f 459eccfd 41d9e58a cf890b22 e49428e9 add21dd1 a483e46a d3c1
    0203 010001
    a3 50304e30 1d060355 1d0e0416 04148888 b8b699e8 44822fcc c1164e95 dd662e58 65ed301f 0603551d 23041830 16801488 88b8b699 e844822f ccc1164e 95dd662e 5865ed30 0c060355 1d130405 30030101 ff300d06 092a8648 86f70d01 01050500 03818100 1d0652cb 2ca15103 b3dbd0c6 4d03ccda fca41d22 75f23e15 aae5e3a3 999d6e59 c0fbb776 f4a6850f b245d87b 05ae7824 2caf472d 0971607e 7d980ee1 0a2b3516 d555b052 b8f83ac0 bccfb9ab 32f53a66 69a61a2c b2887a76 ba67ad1a 15647085 acddebe8 48b0a4cc 4c4c5a5a 39dd6e51 1b840b23 76983a40 cb0ababb 3dfa2ceb 
</code></pre>

<p>可以发现中间那部分就是我们前面的DER编码格式，但是前后那一大段是神马东西呢，这又困扰了我，这个问题先放一放。接下来，要介绍一个最关键的，实际上得益于该作者的成果，我才解决了这个问题，同时也大概知道了上面那一堆大概是神马东东。</p>

<h4>找到通往罗马的道路</h4>

<p>在互联网上搜寻了，找到一篇文章<a href="http://www.ideawu.com/blog/post/132.html">iOS Objective-C RSA encrypt with only public key and descrypt with PHP</a>,这篇文章我看过几次，我一开始认为，里面的公钥就是我上面产生公钥的Base64编码格式，所以，我进行了Base64编码，同时参照其模式，添加了&mdash;&ndash;BEGIN PUBLIC KEY&mdash;&ndash;和&mdash;&ndash;END PUBLIC KEY&mdash;&ndash;，但是依然返回nil，于是我将下面的字符进行Base64解码：</p>

<pre><code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDEChqe80lJLTTkJD3X3Lyd7Fj+
zuOhDZkjuLNPog3YR20e5JcrdqI9IFzNbACY/GQVhbnbvBqYgyql8DfPCGXpn0+X
NSxELIUw9Vh32QuhGNr3/TBpechrVeVpFPLwyaYNEk1CawgHCeQqf5uaqiaoBDOT
qeox88Lc1ld7MsfggQIDAQAB
</code></pre>

<p>得到的数据和DER很像，但是其前面多了一些数据，查看其github上的源码才知道前面还有ASN.1 public key header和PKCS #1 rsaEncryption szOID_RSA_RSA，这个部分解释了上面一长串数据的含义。一开始我忽略了作者这样做的意图，后来我跟踪了从证书中获取公钥，打印了一下SecKeyRef的值，得到下面的结果：</p>

<pre><code>&lt;SecKeyRef algorithm id: 1, key type: RSAPublicKey, version: 3, block size: 1024 bits, exponent: {hex: 10001, decimal: 65537}, modulus: ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1, addr: 0x17c85800&gt;
</code></pre>

<p>这一下子让我想到能不能自己create一个SecKeyRef，因为它的参数我都可以获取，有了这个想法，又经历了一番曲折，最终在阅读ideawu的源码时得到了答案。<a href="https://github.com/codefunny/IOS-RSA/tree/master">源码看这里</a>。剩下的就只有看代码了。</p>

<p>有看到有网友在网上发帖说尝试了很多方式，在IOS上没办法解决这个问题，看到这个我几乎要放弃了，但是最终还是幸运的解决了这个问题，有时候多一次回眸，可能结局就不一样，我们不缺少答案，只是要耐心的寻找。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS安全攻防学习笔记]]></title>
    <link href="http://codefunny.github.io/blog/2014/12/11/ios-safe/"/>
    <updated>2014-12-11T16:59:43+08:00</updated>
    <id>http://codefunny.github.io/blog/2014/12/11/ios-safe</id>
    <content type="html"><![CDATA[<p>前言</p>

<p>在CSDN上发现<a href="http://blog.csdn.net/column/details/hackingios.html?&amp;page=2">程序媛念茜的iOS安全攻防专栏</a>系列文章，在程序猿这个男性居多的行业里见到一女中豪杰，真是巾帼不让须眉，十分佩服念茜，这里就记录一下学习的笔记吧。感谢分享！</p>

<!-- more -->


<h4>工具和命令</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> ps </th>
<th style="text-align:left;"> 显示进程，cpu使用率，内存使用情况等 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> sysctl </td>
<td style="text-align:left;"> 检查设定Kernel配置 </td>
</tr>
<tr>
<td style="text-align:left;">netstat</td>
<td style="text-align:left;">显示网络连接，路由表，接口状态等</td>
</tr>
<tr>
<td style="text-align:left;">route</td>
<td style="text-align:left;">路由</td>
</tr>
<tr>
<td style="text-align:left;">renice</td>
<td style="text-align:left;">调整程序运行优先级</td>
</tr>
<tr>
<td style="text-align:left;">ifconfig</td>
<td style="text-align:left;">查看网络配置</td>
</tr>
<tr>
<td style="text-align:left;">tcpdump</td>
<td style="text-align:left;">截获分析网络数据包</td>
</tr>
<tr>
<td style="text-align:left;">lsof</td>
<td style="text-align:left;">列出当前系统打开的文件列表</td>
</tr>
<tr>
<td style="text-align:left;">otool</td>
<td style="text-align:left;">查看程序依赖的动态库信息，反编代码段。。。</td>
</tr>
<tr>
<td style="text-align:left;">nm</td>
<td style="text-align:left;">显示符号表</td>
</tr>
<tr>
<td style="text-align:left;">ldid</td>
<td style="text-align:left;">签名工具</td>
</tr>
</tbody>
</table>


<p><code>otool -L exe</code> : 显示可执行程序连接了哪些库<br>
<code>otool -tV exe</code>: 反编译exe的<strong>TEXT</strong>段内容<br>
<code>nm -g exe</code>: 显示程序符号表</p>

<h4>阻止GDB依附</h4>

<p>常规的办法是：</p>

<pre><code class="objc">    #import &lt;sys/ptrace.h&gt;  

    int main(int argc, charchar *argv[])  
    {  
    #ifndef DEBUG  
        ptrace(PT_DENY_ATTACH,0,0,0);  
    #endif  
        @autoreleasepool {  
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([WQMainPageAppDelegate class]));  
        }  
    }  
</code></pre>

<p>但是iPhone真实环境没有sys/ptrace.h的，但是可以通过dlopen拿到它。</p>

<p>dlopen：当path参数为0时，他会自动查找$LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH,$DYLD_FALLBACK_LIBRARY_PATH和当前工作目录中的动态链接库。</p>

<pre><code class="objc">    #import &lt;dlfcn.h&gt;  
    #import &lt;sys/types.h&gt;  

    typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);  
    #if !defined(PT_DENY_ATTACH)  
    #define PT_DENY_ATTACH 31  
    #endif  // !defined(PT_DENY_ATTACH)  

    void disable_gdb() {  
        void* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);  
        ptrace_ptr_t ptrace_ptr = dlsym(handle, "ptrace");  
        ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);  
        dlclose(handle);  
    }  

    int main(int argc, charchar *argv[])  
    {  
    #ifndef DEBUG  
        disable_gdb();  
    #endif  
        @autoreleasepool {  
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([WQMainPageAppDelegate class]));  
        }  
    }
</code></pre>

<p><strong>上述方法经过校验可行，但是不知道放在正式版app中是否会被apple驳回。</strong></p>

<h4>二进制和资源文件自检</h4>

<p>hackers们破解app，一般动2个地方，一个是二进制，一个是资源文件。二进制都重新编译了，当然是盗版，但修改资源文件是不需要重新编译二进制文件。</p>

<p>那么，我们有必要在敏感的请求报文中，增加正版应用的二进制和资源文件的标识，让服务器知道，此请求是否来自正版未经修改的app。在沙盒中，读到自己程序的二进制，也可读到资源文件签名文件，对其取md5值然后以某种组合算法得到一个标记字符串，然后发给服务器。</p>

<p>下面是念茜封装的读取文件地址代码</p>

<pre><code class="objc">    @implementation WQPathUtilities  

    + (NSString *)directory:(NSSearchPathDirectory)dir  
    {  
        NSArray *paths = NSSearchPathForDirectoriesInDomains(dir, NSUserDomainMask, YES);  
        NSString *dirStr = [paths objectAtIndex:0];  
        return dirStr;  
    }  

    + (NSString *)documentsDirectory  
    {  
        return [WQPathUtilities directory:NSDocumentDirectory];  
    }  

    + (NSString *)cachesDirectory  
    {  
        return [WQPathUtilities directory:NSCachesDirectory];  
    }  

    + (NSString *)tmpDirectory  
    {  
        return NSTemporaryDirectory();  
    }  

    + (NSString *)homeDirectory  
    {  
        return NSHomeDirectory();  
    }  

    + (NSString *)codeResourcesPath  
    {  
        NSString *excutableName = [[NSBundle mainBundle] infoDictionary][@"CFBundleExecutable"];  
        NSString *tmpPath = [[WQPathUtilities documentsDirectory] stringByDeletingLastPathComponent];  
        NSString *appPath = [[tmpPath stringByAppendingPathComponent:excutableName]  
                             stringByAppendingPathExtension:@"app"];  
        NSString *sigPath = [[appPath stringByAppendingPathComponent:@"_CodeSignature"]  
                             stringByAppendingPathComponent:@"CodeResources"];  
        return sigPath;  
    }  

    + (NSString *)binaryPath  
    {  
        NSString *excutableName = [[NSBundle mainBundle] infoDictionary][@"CFBundleExecutable"];  
        NSString *tmpPath = [[WQPathUtilities documentsDirectory] stringByDeletingLastPathComponent];  
        NSString *appPath = [[tmpPath stringByAppendingPathComponent:excutableName]  
                             stringByAppendingPathExtension:@"app"];  
        NSString *binaryPath = [appPath stringByAppendingPathComponent:excutableName];  
        return binaryPath;  
    }  

    @end  
</code></pre>

<p>md5方法：</p>

<pre><code class="objc">    #import "CommonCrypto/CommonDigest.h"  

    +(NSString *)md5WithString:(NSString *)string  
    {  
        const charchar *cStr = [string UTF8String];  
        unsigned char result[CC_MD5_DIGEST_LENGTH];  
        CC_MD5(cStr, strlen(cStr), result);  

        return [[NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",  
                 result[0], result[1], result[2], result[3],  
                 result[4], result[5], result[6], result[7],  
                 result[8], result[9], result[10], result[11],  
                 result[12], result[13], result[14], result[15]  
                 ] lowercaseString];  
    }  
</code></pre>

<h4>static和被裁的符号表</h4>

<p>原理：</p>

<p>如果函数属性为static，那么编译时该函数符号就会被解析为local符号。在发布release程序时（xcode打包编译二进制）默认会strip裁掉这些函数符号，加大破解难度。</p>

<p>局限：static函数，只在本文件可见。</p>

<pre><code class="objc">    static id static_createBtn()  
    {  
        UIButton *btn = [[UIButton alloc]initWithFrame:CGRectZero];  
        [btn setFrame:CGRectMake(50, 100, 100, 100)];  
        [btn setBackgroundColor:[UIColor blueColor]];  
        btn.layer.cornerRadius = 7.0f;  
        btn.layer.masksToBounds = YES;  
        return btn;  
    } 
</code></pre>

<h4>方法名混淆</h4>

<p>常规思路：</p>

<ul>
<li>花代码花指令，即随意往程序中加入迷惑人的代码指令</li>
<li>易读字符替换</li>
</ul>


<p>念茜写了一个混淆工具，主要思路是把敏感方法名集中写在一个名叫func.list的文件中，逐一#define成随机字符，追加写入.h</p>

<pre><code class="objc">    #!/usr/bin/env bash  

    TABLENAME=symbols  
    SYMBOL_DB_FILE="symbols"  
    STRING_SYMBOL_FILE="func.list"  
    HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"  
    export LC_CTYPE=C  

    #维护数据库方便日后作排重  
    createTable()  
    {  
        echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE  
    }  

    insertValue()  
    {  
        echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE  
    }  

    query()  
    {  
        echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE  
    }  

    ramdomString()  
    {  
        openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16  
    }  

    rm -f $SYMBOL_DB_FILE  
    rm -f $HEAD_FILE  
    createTable  

    touch $HEAD_FILE  
    echo '#ifndef Demo_codeObfuscation_h  
    #define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILE  
    echo "//confuse string at `date`" &gt;&gt; $HEAD_FILE  
    cat "$STRING_SYMBOL_FILE" | while read -ra line; do  
        if [[ ! -z "$line" ]]; then  
            ramdom=`ramdomString`  
            echo $line $ramdom  
            insertValue $line $ramdom  
            echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE  
        fi  
    done  
    echo "#endif" &gt;&gt; $HEAD_FILE  


    sqlite3 $SYMBOL_DB_FILE .dump  
</code></pre>

<p><a href="http://blog.csdn.net/yxh265/article/details/38438959">这里</a>有人用c写了一个获取m中方法的程序。</p>

<h4>敏感代码保护</h4>

<p>Object-C代码容易被hook，暴露信息太多，为了安全，改用C来写敏感的业务逻辑吧。</p>

<p>示例：</p>

<pre><code class="objc">    //XXUtil.h  
    #import &lt;Foundation/Foundation.h&gt;  

    typedef struct _util {  
        BOOL (*isVerified)(void);  
        BOOL (*isNeedSomething)(void);  
        void (*resetPassword)(NSString *password);  
    }XXUtil_t ;  

    #define XXUtil ([_XXUtil sharedUtil])  

    @interface _XXUtil : NSObject  

    + (XXUtil_t *)sharedUtil;  
    @end  

    //XXUtil.m  
    #import "XXUtil.h"  

    static BOOL _isVerified(void)  
    {  
        //bala bala ...  
        return YES;  
    }  

    static BOOL _isNeedSomething(void)  
    {  
        //bala bala ...  
        return YES;  
    }  

    static void _resetPassword(NSString *password)  
    {  
        //bala bala ...  
    }  

    static XXUtil_t * util = NULL;  
    @implementation _XXUtil  

    +(XXUtil_t *)sharedUtil  
    {  
        static dispatch_once_t onceToken;  
        dispatch_once(&amp;onceToken, ^{  
            util = malloc(sizeof(XXUtil_t));  
            util-&gt;isVerified = _isVerified;  
            util-&gt;isNeedSomething = _isNeedSomething;  
            util-&gt;resetPassword = _resetPassword;  
        });  
        return util;  
    }  

    + (void)destroy  
    {  
        util ? free(util): 0;  
        util = NULL;  
    }  
    @end  
</code></pre>

<h4>判断设备是否越狱</h4>

<p><a href="http://blog.csdn.net/sakulafly/article/details/21159257">直接看原文吧</a></p>
]]></content>
  </entry>
  
</feed>
