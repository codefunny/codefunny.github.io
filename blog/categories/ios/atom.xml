<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Peter's Blog]]></title>
  <link href="http://codefunny.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://codefunny.github.io/"/>
  <updated>2015-07-23T12:25:24+08:00</updated>
  <id>http://codefunny.github.io/</id>
  <author>
    <name><![CDATA[Peter]]></name>
    <email><![CDATA[winchaozheng@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【IOS】Reveal利器之使用]]></title>
    <link href="http://codefunny.github.io/blog/2015/07/23/ios-reveal-apply/"/>
    <updated>2015-07-23T12:00:01+08:00</updated>
    <id>http://codefunny.github.io/blog/2015/07/23/ios-reveal-apply</id>
    <content type="html"><![CDATA[<p>网上有很多教程，我结合自己的经验，总结了一个方便地使用方法，在下面描述我的使用流程。</p>

<!-- more -->


<p>1.获得Reveal的framework，在Reveal中拿到Reveal.framework拷贝到一个目录，本地调试UI都引用这个目录的framework，不用copy到具体的工程中；</p>

<p>2.在工程中新建一个Tagets，命名位RevealTest区分一下，然后在Build Setting中的Other Linker Flags项添加-ObjC -framework Reveal两项；</p>

<p>3.别忘了在Linked Frameworks and Libraries中添加Reveal.framework进来。</p>

<p>4.接下来就是启动Reveal和工程了，注意要编译的是RevealTest目标，这样就不用担心对生产版本造成影响了。</p>

<p>附：比较方便的办法是copy一下TARGETS，然后添加上面的设置，不过copy一份targets发现identifier后面加了一个copy字样，可能会有一些警告之类的信息，可以到Build Setting中修改Product Name，去掉后面的copy字符即可。</p>

<p>展示一个我的项目的UI截图，</p>

<p><img src="http://codefunny.github.io/images/custom_images/zhiyue-reveal.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【IOS】只有RSA模和指数，如何完成加密]]></title>
    <link href="http://codefunny.github.io/blog/2015/07/04/ios-rsa/"/>
    <updated>2015-07-04T17:02:23+08:00</updated>
    <id>http://codefunny.github.io/blog/2015/07/04/ios-rsa</id>
    <content type="html"><![CDATA[<blockquote><p>最近在项目中遇到RSA的加密解密问题，如果采用一般证书的方式也就没有这篇文章了，情况是这样的，RSA公钥存在服务器，需要联机获取，可以获取到RSA密钥的模值、有效期、指数、算法标识、索引等信息，这些信息是ASCII码格式，这些信息如何利用IOS的加密API进行RSA运算就成了一个问题。这篇文章就是记述探索问题答案的过程，希望对遇到同样问题的同行有所帮助。</p></blockquote>

<!-- more -->


<h4>获取的RSA模和指数</h4>

<pre><code>modulus: ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1
exponent:
010001
</code></pre>

<p>这是ASCII格式的公钥，在网上查询了一下RSA公钥的格式，发现X.509 DER编码和X.509 PAM编码，其中DER编码是ASCII格式，PAM编码是Base64格式，且他们只放证书，不含私钥。根据模值，可以判断，我们采用的应该是DER编码。那么DER编码的格式，就要弄清楚一下了。</p>

<h4>X.509 DER编码格式</h4>

<p>网上有一篇文章<a href="http://m.blog.csdn.net/blog/lingruoshui/11473755">RSA公钥DER编码</a>根据这篇文章可以推断出我们的DER编码格式应该是这样的，</p>

<pre><code>30818902818100ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C10203010001
解析一下可以分成以下几个部分（大家可以了解以下TLV结构）：
308189：30开始，81代表后面一个字节表示长度，89表示后面有137字节；
028181：02开始，81同上，81表示modulus长度129，前面补了00；
00ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1：modulus
0203010001：02开始，03表示后面三个字节，exponent值（010001）。
</code></pre>

<h4>RSA在IOS中的常见用法</h4>

<p><a href="http://blog.iamzsx.me/show.html?id=155002">iOS下的RSA加密方法</a>这篇文章常见用法之一，使用公钥证书，利用系统方法最终获得<strong>SecKeyRef publicKey</strong>，但是我们现在遇到的问题就是没有证书，我尝试过利用上面组装的DER送给<strong>SecCertificateCreateWithData</strong>，但是结果是返回nil值，这说明，我们的格式还不是该方法的参数，那么该方法的参数是神马呢，我跟踪了一个公钥证书，打印NSData值，发现其编码格式如下（中间部分经过我的处理，方便大家观察）：</p>

<pre><code>308202e4 3082024d a0030201 02020900 b524e21a d8b61f68 300d0609 2a864886 f70d0101 05050030 818a310b 30090603 55040613 02434e31 11300f06 03550408 0c085368 616e6768 61693111 300f0603 5504070c 08536861 6e676861 69310e30 0c060355 040a0c05 42616979 69310e30 0c060355 040b0c05 42616979 69311030 0e060355 04030c07 596f726b 2e477531 23302106 092a8648 86f70d01 09011614 67797135 33313939 32304067 6d61696c 2e636f6d 301e170d 31313130 32363032 34353332 5a170d31 31313132 35303234 3533335a 30818a31 0b300906 03550406 1302434e 3111300f 06035504 080c0853 68616e67 68616931 11300f06 03550407 0c085368 616e6768 6169310e 300c0603 55040a0c 05426169 7969310e 300c0603 55040b0c 05426169 79693110 300e0603 5504030c 07596f72 6b2e4775 31233021 06092a86 4886f70d 01090116 14677971 35333139 39323040 676d6169 6c2e636f 6d30819f
    300d0609 2a864886 f70d0101 010500
    03 818d
    0030 81890281 81
    00addc 2b26bba0 e8bc8d53 2444656e 367fd289 24b5cb99 2728b87a b7df09ba 4043259a a8df42d5 3d75cbf6 71dc6170 53ba5260 ceeb4238 6431c3c3 837c02af 5d8c665f b42f2f09 49445133 aeace2dd e00cd856 2d65978a 6e057a3f 18a63b00 86e83a9a 16a77c5f 459eccfd 41d9e58a cf890b22 e49428e9 add21dd1 a483e46a d3c1
    0203 010001
    a3 50304e30 1d060355 1d0e0416 04148888 b8b699e8 44822fcc c1164e95 dd662e58 65ed301f 0603551d 23041830 16801488 88b8b699 e844822f ccc1164e 95dd662e 5865ed30 0c060355 1d130405 30030101 ff300d06 092a8648 86f70d01 01050500 03818100 1d0652cb 2ca15103 b3dbd0c6 4d03ccda fca41d22 75f23e15 aae5e3a3 999d6e59 c0fbb776 f4a6850f b245d87b 05ae7824 2caf472d 0971607e 7d980ee1 0a2b3516 d555b052 b8f83ac0 bccfb9ab 32f53a66 69a61a2c b2887a76 ba67ad1a 15647085 acddebe8 48b0a4cc 4c4c5a5a 39dd6e51 1b840b23 76983a40 cb0ababb 3dfa2ceb 
</code></pre>

<p>可以发现中间那部分就是我们前面的DER编码格式，但是前后那一大段是神马东西呢，这又困扰了我，这个问题先放一放。接下来，要介绍一个最关键的，实际上得益于该作者的成果，我才解决了这个问题，同时也大概知道了上面那一堆大概是神马东东。</p>

<h4>找到通往罗马的道路</h4>

<p>在互联网上搜寻了，找到一篇文章<a href="http://www.ideawu.com/blog/post/132.html">iOS Objective-C RSA encrypt with only public key and descrypt with PHP</a>,这篇文章我看过几次，我一开始认为，里面的公钥就是我上面产生公钥的Base64编码格式，所以，我进行了Base64编码，同时参照其模式，添加了&mdash;&ndash;BEGIN PUBLIC KEY&mdash;&ndash;和&mdash;&ndash;END PUBLIC KEY&mdash;&ndash;，但是依然返回nil，于是我将下面的字符进行Base64解码：</p>

<pre><code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDEChqe80lJLTTkJD3X3Lyd7Fj+
zuOhDZkjuLNPog3YR20e5JcrdqI9IFzNbACY/GQVhbnbvBqYgyql8DfPCGXpn0+X
NSxELIUw9Vh32QuhGNr3/TBpechrVeVpFPLwyaYNEk1CawgHCeQqf5uaqiaoBDOT
qeox88Lc1ld7MsfggQIDAQAB
</code></pre>

<p>得到的数据和DER很像，但是其前面多了一些数据，查看其github上的源码才知道前面还有ASN.1 public key header和PKCS #1 rsaEncryption szOID_RSA_RSA，这个部分解释了上面一长串数据的含义。一开始我忽略了作者这样做的意图，后来我跟踪了从证书中获取公钥，打印了一下SecKeyRef的值，得到下面的结果：</p>

<pre><code>&lt;SecKeyRef algorithm id: 1, key type: RSAPublicKey, version: 3, block size: 1024 bits, exponent: {hex: 10001, decimal: 65537}, modulus: ADDC2B26BBA0E8BC8D532444656E367FD28924B5CB992728B87AB7DF09BA4043259AA8DF42D53D75CBF671DC617053BA5260CEEB42386431C3C3837C02AF5D8C665FB42F2F0949445133AEACE2DDE00CD8562D65978A6E057A3F18A63B0086E83A9A16A77C5F459ECCFD41D9E58ACF890B22E49428E9ADD21DD1A483E46AD3C1, addr: 0x17c85800&gt;
</code></pre>

<p>这一下子让我想到能不能自己create一个SecKeyRef，因为它的参数我都可以获取，有了这个想法，又经历了一番曲折，最终在阅读ideawu的源码时得到了答案。<a href="https://github.com/codefunny/IOS-RSA/tree/master">源码看这里</a>。剩下的就只有看代码了。</p>

<p>有看到有网友在网上发帖说尝试了很多方式，在IOS上没办法解决这个问题，看到这个我几乎要放弃了，但是最终还是幸运的解决了这个问题，有时候多一次回眸，可能结局就不一样，我们不缺少答案，只是要耐心的寻找。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS安全攻防学习笔记]]></title>
    <link href="http://codefunny.github.io/blog/2014/12/11/ios-safe/"/>
    <updated>2014-12-11T16:59:43+08:00</updated>
    <id>http://codefunny.github.io/blog/2014/12/11/ios-safe</id>
    <content type="html"><![CDATA[<p>前言</p>

<p>在CSDN上发现<a href="http://blog.csdn.net/column/details/hackingios.html?&amp;page=2">程序媛念茜的iOS安全攻防专栏</a>系列文章，在程序猿这个男性居多的行业里见到一女中豪杰，真是巾帼不让须眉，十分佩服念茜，这里就记录一下学习的笔记吧。感谢分享！</p>

<!-- more -->


<h4>工具和命令</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> ps </th>
<th style="text-align:left;"> 显示进程，cpu使用率，内存使用情况等 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> sysctl </td>
<td style="text-align:left;"> 检查设定Kernel配置 </td>
</tr>
<tr>
<td style="text-align:left;">netstat</td>
<td style="text-align:left;">显示网络连接，路由表，接口状态等</td>
</tr>
<tr>
<td style="text-align:left;">route</td>
<td style="text-align:left;">路由</td>
</tr>
<tr>
<td style="text-align:left;">renice</td>
<td style="text-align:left;">调整程序运行优先级</td>
</tr>
<tr>
<td style="text-align:left;">ifconfig</td>
<td style="text-align:left;">查看网络配置</td>
</tr>
<tr>
<td style="text-align:left;">tcpdump</td>
<td style="text-align:left;">截获分析网络数据包</td>
</tr>
<tr>
<td style="text-align:left;">lsof</td>
<td style="text-align:left;">列出当前系统打开的文件列表</td>
</tr>
<tr>
<td style="text-align:left;">otool</td>
<td style="text-align:left;">查看程序依赖的动态库信息，反编代码段。。。</td>
</tr>
<tr>
<td style="text-align:left;">nm</td>
<td style="text-align:left;">显示符号表</td>
</tr>
<tr>
<td style="text-align:left;">ldid</td>
<td style="text-align:left;">签名工具</td>
</tr>
</tbody>
</table>


<p><code>otool -L exe</code> : 显示可执行程序连接了哪些库<br>
<code>otool -tV exe</code>: 反编译exe的<strong>TEXT</strong>段内容<br>
<code>nm -g exe</code>: 显示程序符号表</p>

<h4>阻止GDB依附</h4>

<p>常规的办法是：</p>

<pre><code class="objc">    #import &lt;sys/ptrace.h&gt;  

    int main(int argc, charchar *argv[])  
    {  
    #ifndef DEBUG  
        ptrace(PT_DENY_ATTACH,0,0,0);  
    #endif  
        @autoreleasepool {  
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([WQMainPageAppDelegate class]));  
        }  
    }  
</code></pre>

<p>但是iPhone真实环境没有sys/ptrace.h的，但是可以通过dlopen拿到它。</p>

<p>dlopen：当path参数为0时，他会自动查找$LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH,$DYLD_FALLBACK_LIBRARY_PATH和当前工作目录中的动态链接库。</p>

<pre><code class="objc">    #import &lt;dlfcn.h&gt;  
    #import &lt;sys/types.h&gt;  

    typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);  
    #if !defined(PT_DENY_ATTACH)  
    #define PT_DENY_ATTACH 31  
    #endif  // !defined(PT_DENY_ATTACH)  

    void disable_gdb() {  
        void* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);  
        ptrace_ptr_t ptrace_ptr = dlsym(handle, "ptrace");  
        ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);  
        dlclose(handle);  
    }  

    int main(int argc, charchar *argv[])  
    {  
    #ifndef DEBUG  
        disable_gdb();  
    #endif  
        @autoreleasepool {  
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([WQMainPageAppDelegate class]));  
        }  
    }
</code></pre>

<p><strong>上述方法经过校验可行，但是不知道放在正式版app中是否会被apple驳回。</strong></p>

<h4>二进制和资源文件自检</h4>

<p>hackers们破解app，一般动2个地方，一个是二进制，一个是资源文件。二进制都重新编译了，当然是盗版，但修改资源文件是不需要重新编译二进制文件。</p>

<p>那么，我们有必要在敏感的请求报文中，增加正版应用的二进制和资源文件的标识，让服务器知道，此请求是否来自正版未经修改的app。在沙盒中，读到自己程序的二进制，也可读到资源文件签名文件，对其取md5值然后以某种组合算法得到一个标记字符串，然后发给服务器。</p>

<p>下面是念茜封装的读取文件地址代码</p>

<pre><code class="objc">    @implementation WQPathUtilities  

    + (NSString *)directory:(NSSearchPathDirectory)dir  
    {  
        NSArray *paths = NSSearchPathForDirectoriesInDomains(dir, NSUserDomainMask, YES);  
        NSString *dirStr = [paths objectAtIndex:0];  
        return dirStr;  
    }  

    + (NSString *)documentsDirectory  
    {  
        return [WQPathUtilities directory:NSDocumentDirectory];  
    }  

    + (NSString *)cachesDirectory  
    {  
        return [WQPathUtilities directory:NSCachesDirectory];  
    }  

    + (NSString *)tmpDirectory  
    {  
        return NSTemporaryDirectory();  
    }  

    + (NSString *)homeDirectory  
    {  
        return NSHomeDirectory();  
    }  

    + (NSString *)codeResourcesPath  
    {  
        NSString *excutableName = [[NSBundle mainBundle] infoDictionary][@"CFBundleExecutable"];  
        NSString *tmpPath = [[WQPathUtilities documentsDirectory] stringByDeletingLastPathComponent];  
        NSString *appPath = [[tmpPath stringByAppendingPathComponent:excutableName]  
                             stringByAppendingPathExtension:@"app"];  
        NSString *sigPath = [[appPath stringByAppendingPathComponent:@"_CodeSignature"]  
                             stringByAppendingPathComponent:@"CodeResources"];  
        return sigPath;  
    }  

    + (NSString *)binaryPath  
    {  
        NSString *excutableName = [[NSBundle mainBundle] infoDictionary][@"CFBundleExecutable"];  
        NSString *tmpPath = [[WQPathUtilities documentsDirectory] stringByDeletingLastPathComponent];  
        NSString *appPath = [[tmpPath stringByAppendingPathComponent:excutableName]  
                             stringByAppendingPathExtension:@"app"];  
        NSString *binaryPath = [appPath stringByAppendingPathComponent:excutableName];  
        return binaryPath;  
    }  

    @end  
</code></pre>

<p>md5方法：</p>

<pre><code class="objc">    #import "CommonCrypto/CommonDigest.h"  

    +(NSString *)md5WithString:(NSString *)string  
    {  
        const charchar *cStr = [string UTF8String];  
        unsigned char result[CC_MD5_DIGEST_LENGTH];  
        CC_MD5(cStr, strlen(cStr), result);  

        return [[NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",  
                 result[0], result[1], result[2], result[3],  
                 result[4], result[5], result[6], result[7],  
                 result[8], result[9], result[10], result[11],  
                 result[12], result[13], result[14], result[15]  
                 ] lowercaseString];  
    }  
</code></pre>

<h4>static和被裁的符号表</h4>

<p>原理：</p>

<p>如果函数属性为static，那么编译时该函数符号就会被解析为local符号。在发布release程序时（xcode打包编译二进制）默认会strip裁掉这些函数符号，加大破解难度。</p>

<p>局限：static函数，只在本文件可见。</p>

<pre><code class="objc">    static id static_createBtn()  
    {  
        UIButton *btn = [[UIButton alloc]initWithFrame:CGRectZero];  
        [btn setFrame:CGRectMake(50, 100, 100, 100)];  
        [btn setBackgroundColor:[UIColor blueColor]];  
        btn.layer.cornerRadius = 7.0f;  
        btn.layer.masksToBounds = YES;  
        return btn;  
    } 
</code></pre>

<h4>方法名混淆</h4>

<p>常规思路：</p>

<ul>
<li>花代码花指令，即随意往程序中加入迷惑人的代码指令</li>
<li>易读字符替换</li>
</ul>


<p>念茜写了一个混淆工具，主要思路是把敏感方法名集中写在一个名叫func.list的文件中，逐一#define成随机字符，追加写入.h</p>

<pre><code class="objc">    #!/usr/bin/env bash  

    TABLENAME=symbols  
    SYMBOL_DB_FILE="symbols"  
    STRING_SYMBOL_FILE="func.list"  
    HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"  
    export LC_CTYPE=C  

    #维护数据库方便日后作排重  
    createTable()  
    {  
        echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE  
    }  

    insertValue()  
    {  
        echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE  
    }  

    query()  
    {  
        echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE  
    }  

    ramdomString()  
    {  
        openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16  
    }  

    rm -f $SYMBOL_DB_FILE  
    rm -f $HEAD_FILE  
    createTable  

    touch $HEAD_FILE  
    echo '#ifndef Demo_codeObfuscation_h  
    #define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILE  
    echo "//confuse string at `date`" &gt;&gt; $HEAD_FILE  
    cat "$STRING_SYMBOL_FILE" | while read -ra line; do  
        if [[ ! -z "$line" ]]; then  
            ramdom=`ramdomString`  
            echo $line $ramdom  
            insertValue $line $ramdom  
            echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE  
        fi  
    done  
    echo "#endif" &gt;&gt; $HEAD_FILE  


    sqlite3 $SYMBOL_DB_FILE .dump  
</code></pre>

<p><a href="http://blog.csdn.net/yxh265/article/details/38438959">这里</a>有人用c写了一个获取m中方法的程序。</p>

<h4>敏感代码保护</h4>

<p>Object-C代码容易被hook，暴露信息太多，为了安全，改用C来写敏感的业务逻辑吧。</p>

<p>示例：</p>

<pre><code class="objc">    //XXUtil.h  
    #import &lt;Foundation/Foundation.h&gt;  

    typedef struct _util {  
        BOOL (*isVerified)(void);  
        BOOL (*isNeedSomething)(void);  
        void (*resetPassword)(NSString *password);  
    }XXUtil_t ;  

    #define XXUtil ([_XXUtil sharedUtil])  

    @interface _XXUtil : NSObject  

    + (XXUtil_t *)sharedUtil;  
    @end  

    //XXUtil.m  
    #import "XXUtil.h"  

    static BOOL _isVerified(void)  
    {  
        //bala bala ...  
        return YES;  
    }  

    static BOOL _isNeedSomething(void)  
    {  
        //bala bala ...  
        return YES;  
    }  

    static void _resetPassword(NSString *password)  
    {  
        //bala bala ...  
    }  

    static XXUtil_t * util = NULL;  
    @implementation _XXUtil  

    +(XXUtil_t *)sharedUtil  
    {  
        static dispatch_once_t onceToken;  
        dispatch_once(&amp;onceToken, ^{  
            util = malloc(sizeof(XXUtil_t));  
            util-&gt;isVerified = _isVerified;  
            util-&gt;isNeedSomething = _isNeedSomething;  
            util-&gt;resetPassword = _resetPassword;  
        });  
        return util;  
    }  

    + (void)destroy  
    {  
        util ? free(util): 0;  
        util = NULL;  
    }  
    @end  
</code></pre>

<h4>判断设备是否越狱</h4>

<p><a href="http://blog.csdn.net/sakulafly/article/details/21159257">直接看原文吧</a></p>
]]></content>
  </entry>
  
</feed>
